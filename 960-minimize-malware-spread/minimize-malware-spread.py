class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        visited = [False] * n
        
        # Step 1: Find connected components
        def dfs(node, comp):
            visited[node] = True
            comp.append(node)
            for nei in range(n):
                if graph[node][nei] == 1 and not visited[nei]:
                    dfs(nei, comp)
        
        components = []
        for i in range(n):
            if not visited[i]:
                comp = []
                dfs(i, comp)
                components.append(comp)
        
        # Step 2: Count infections in each component
        comp_index = {}
        for i, comp in enumerate(components):
            for node in comp:
                comp_index[node] = i
        
        infected_count = [0] * len(components)
        comp_size = [len(c) for c in components]
        
        for node in initial:
            infected_count[comp_index[node]] += 1
        
        # Step 3: Find the best node to remove
        res = -1
        max_saved = 0
        
        for node in sorted(initial):  # sorted for smallest index tie-breaking
            ci = comp_index[node]
            if infected_count[ci] == 1:  # only one infected in this component
                saved = comp_size[ci]
                if saved > max_saved:
                    max_saved = saved
                    res = node
        
        return res if res != -1 else min(initial)
